<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>FLAPPY PORK</title>
<style>
  :root {
    --ui-shadow: 2px 2px 4px rgba(0,0,0,0.7);
  }
  html,body {
    margin:0; padding:0; height:100%; width:100%;
    font-family: Arial, sans-serif;
    background: linear-gradient(135deg,#4a90e2,#7b68ee,#87ceeb);
    overflow:hidden;
    position: fixed;
    touch-action: none;
  }
  #gameContainer {
    position:relative; width:100vw; height:100vh; overflow:hidden;
    background: linear-gradient(to bottom,#87ceeb 0%,#4682b4 50%,#1e90ff 100%);
  }
  canvas { 
    display:block; width:100%; height:100%;
    background: linear-gradient(to bottom,#87ceeb 0%,#4682b4 30%,#4169e1 70%,#0047ab 100%);
    touch-action: none;
  }
  #gameUI {
    position:absolute; top:10px; left:10px; color:#fff;
    font-size:18px; font-weight:bold; text-shadow:var(--ui-shadow);
    z-index:10; display:none; user-select:none;
  }
  
  @media (max-width: 768px) {
    #gameUI {
      font-size:16px;
      top:5px;
      left:5px;
    }
  }
  
  #startScreen, #gameOver {
    position:absolute; 
    left:50%; 
    top:50%; 
    transform:translate(-50%,-50%);
    background: rgba(0,0,0,0.9); 
    color:#fff; 
    padding:20px; 
    border-radius:14px;
    text-align:center; 
    z-index:20; 
    user-select:none;
    max-width:90vw;
    max-height:90vh;
    overflow-y: auto;
    box-sizing: border-box;
  }
  
  @media (max-width: 768px) {
    #startScreen, #gameOver {
      padding:15px;
      border-radius:10px;
      max-width:95vw;
    }
  }
  
  #gameOver { display:none; }
  
  .game-button {
    background:#4a90e2; color:#00ffff; border:none; padding:12px 22px;
    font-size:16px; font-weight:bold; font-family:'Courier New', monospace;
    border-radius:8px; cursor:pointer; margin:10px; transition:background .2s ease;
    text-shadow:0 0 5px #00ffff,0 0 10px #00ffff,2px 2px 0px #ff00ff;
    letter-spacing:1px; text-transform:uppercase;
    min-height:44px;
    display:inline-block;
  }
  .game-button:hover { background:#357abd; }
  .game-button:active { transform: scale(0.95); }
  
  @media (max-width: 768px) {
    .game-button {
      font-size:14px;
      padding:10px 18px;
      margin:8px;
    }
  }
  
  .game-title {
    font-size:48px; font-weight:900; margin:16px 0 6px;
    color:#ff00ff; letter-spacing:3px; text-transform:uppercase;
    text-shadow:0 0 10px #ff00ff,0 0 20px #ff00ff,0 0 40px #ff00ff,4px 4px 0px #00ffff,8px 8px 0px #ffff00;
    background: linear-gradient(45deg,#ff00ff,#00ffff,#ffff00,#ff00ff);
    background-size:400% 400%; -webkit-background-clip:text; background-clip:text;
    -webkit-text-fill-color:transparent; 
    line-height: 1.1;
  }
  
  @media (max-width: 768px) {
    .game-title {
      font-size:26px;
      letter-spacing:1px;
      margin:12px 0 6px;
    }
  }
  
  @media (max-width: 480px) {
    .game-title {
      font-size:22px;
      letter-spacing:0.5px;
      margin:8px 0 4px;
    }
  }
  
  .high-score-display {
    margin: 10px 0 15px 0;
    padding: 8px 12px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    border: 1px solid rgba(0,255,255,0.3);
  }
  
  .high-score-item {
    font-size: 14px;
    color: #00ffff;
    text-shadow: 0 0 5px #00ffff;
    margin: 2px 0;
    font-family: 'Courier New', monospace;
    font-weight: bold;
  }
  
  .score-comparison {
    margin: 15px 0;
  }
  
  .high-score-section {
    padding: 8px 12px;
    background: rgba(255,215,0,0.1);
    border-radius: 6px;
    border: 1px solid rgba(255,215,0,0.3);
    margin-top: 8px;
  }
  
  .high-score-label {
    margin: 4px 0 !important;
    font-size: 12px;
    opacity: 0.9;
  }
  
  .new-record {
    animation: recordPulse 0.8s ease-in-out infinite alternate;
    color: #ffd700 !important;
    text-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700 !important;
  }
  
  @keyframes recordPulse {
    from { transform: scale(1); }
    to { transform: scale(1.05); }
  }
  
  .game-subtitle {
    font-size:14px; font-weight:bold; font-family:'Courier New', monospace;
    color:#00ffff; text-shadow:0 0 5px #00ffff,0 0 10px #00ffff,2px 2px 0px #ff00ff;
    margin:8px 0; letter-spacing:1px; text-transform:uppercase;
    line-height: 1.3;
  }
  
  @media (max-width: 768px) {
    .game-subtitle {
      font-size:12px;
      margin:6px 0;
      letter-spacing:0.5px;
    }
  }
  
  #hint { 
    font-size:12px; 
    opacity:.8; 
    margin-top:6px; 
    line-height: 1.4;
  }
  
  @media (max-width: 768px) {
    #hint {
      font-size:11px;
      margin-top:4px;
    }
  }
</style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="gameUI">
      <div>Score: <span id="score">0</span></div>
      <div>Badges: <span id="badges">0</span></div>
    </div>

    <div id="startScreen">
      <h1 class="game-title">ü´ß FLAPPY PORK ü´ß</h1>
      <div class="high-score-display">
        <div class="high-score-item">üèÜ High Score: <span id="highScore">0</span></div>
        <div class="high-score-item">üéñÔ∏è Best Badges: <span id="highBadges">0</span></div>
      </div>
      <p class="game-subtitle">Navigate the pond</p>
      <p class="game-subtitle">Collect the badges, GET HIGH SCORE</p>
      <button class="game-button" id="startBtn">Start Game</button>
      <div id="hint">TIP: TAP/HOLD SCREEN OR PRESS/HOLD SPACE TO RISE.</div>
    </div>

    <div id="gameOver">
      <h1 class="game-title">Game Over</h1>
      <div class="score-comparison">
        <div class="current-score">
          <p class="game-subtitle">Final Score: <span id="finalScore">0</span></p>
          <p class="game-subtitle">Badges Collected: <span id="finalBadges">0</span></p>
        </div>
        <div class="high-score-section">
          <p class="game-subtitle high-score-label">Personal Best:</p>
          <p class="game-subtitle">üèÜ <span id="finalHighScore">0</span> | üéñÔ∏è <span id="finalHighBadges">0</span></p>
        </div>
      </div>
      <button class="game-button" id="restartBtn">Flap Again</button>
      <button class="game-button" id="homeBtn" style="font-size:12px; padding:8px 16px; margin:5px;">HOME</button>
    </div>
  </div>

<script>
// Canvas Setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  canvas.displayWidth = window.innerWidth;
  canvas.displayHeight = window.innerHeight;
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game State
let gameState = 'start';
let score = 0;
let badgeCount = 0;
let frame = 0;
let isSpacePressed = false;
let isMousePressed = false;
let gameSpeed = 1;
let highScore = 0;
let highBadges = 0;

// In-memory storage
let gameData = {
  highScore: 0,
  highBadges: 0
};

function loadHighScore() {
  highScore = gameData.highScore;
  highBadges = gameData.highBadges;
  updateHighScoreDisplay();
}

function saveHighScore() {
  gameData.highScore = highScore;
  gameData.highBadges = highBadges;
}

function updateHighScoreDisplay() {
  document.getElementById('highScore').textContent = highScore;
  document.getElementById('highBadges').textContent = highBadges;
  document.getElementById('finalHighScore').textContent = highScore;
  document.getElementById('finalHighBadges').textContent = highBadges;
}

// Player
const player = {
  x: 100,
  y: 300,
  width: 40,
  height: 40,
  velocity: 0,
  gravity: 0.40,
  upForce: -0.60,
  maxUpVelocity: -8,
  maxDownVelocity: 8
};

let pipes = [];
let badges = [];
let particles = [];

const badgeTypes = ['‚õèÔ∏è','ü§ù','üê∑','üíé','üë®‚Äçüç≥','üê∞','üò≠','ü•Ω','ü•º','‚úä','‚ú®'];

// Enhanced 8-bit Audio System
let audioContext = null;
let masterGain = null;
let musicGain = null;
let sfxGain = null;
let musicRunning = false;
let musicSchedulerId = null;

function initAudio() {
  try {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create audio routing
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.7;
      masterGain.connect(audioContext.destination);

      musicGain = audioContext.createGain();
      musicGain.gain.value = 0.08; // Subtle background music
      musicGain.connect(masterGain);

      sfxGain = audioContext.createGain();
      sfxGain.gain.value = 0.4; // Sound effects volume
      sfxGain.connect(masterGain);
    }
    
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
  } catch (e) {
    console.log('Audio not available');
  }
}

// 8-bit Music System
function startMusic() {
  if (!audioContext || musicRunning) return;
  
  try {
    musicRunning = true;
    
    const tempo = 120; // BPM
    const beatDuration = 60 / tempo; // Quarter note duration
    const patternLength = 16; // 4 bars of 4/4 time
    
    // C Major scale frequencies
    const scale = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
    
    // Simple melodies
    const leadMelody = [0,2,4,7, 7,4,2,0, 0,2,4,7, 7,4,2,0];
    const bassMelody = [0,0,0,0, 5,5,5,5, 3,3,3,3, 4,4,4,4];
    
    function schedulePattern(startTime) {
      for (let i = 0; i < patternLength; i++) {
        const noteTime = startTime + i * beatDuration;
        
        // Lead melody (square wave)
        const leadOsc = audioContext.createOscillator();
        const leadGain = audioContext.createGain();
        leadOsc.type = 'square';
        leadOsc.frequency.value = scale[leadMelody[i] % scale.length];
        
        // Envelope
        leadGain.gain.setValueAtTime(0, noteTime);
        leadGain.gain.linearRampToValueAtTime(0.15, noteTime + 0.01);
        leadGain.gain.exponentialRampToValueAtTime(0.001, noteTime + beatDuration * 0.9);
        
        leadOsc.connect(leadGain).connect(musicGain);
        leadOsc.start(noteTime);
        leadOsc.stop(noteTime + beatDuration);
        
        // Bass line (square wave, lower octave)
        const bassOsc = audioContext.createOscillator();
        const bassGain = audioContext.createGain();
        bassOsc.type = 'square';
        bassOsc.frequency.value = scale[bassMelody[i] % scale.length] / 2;
        
        bassGain.gain.setValueAtTime(0, noteTime);
        bassGain.gain.linearRampToValueAtTime(0.1, noteTime + 0.01);
        bassGain.gain.exponentialRampToValueAtTime(0.001, noteTime + beatDuration * 0.95);
        
        bassOsc.connect(bassGain).connect(musicGain);
        bassOsc.start(noteTime);
        bassOsc.stop(noteTime + beatDuration);
        
        // Hi-hat (noise burst on eighth notes)
        for (let j = 0; j < 2; j++) {
          const hihatTime = noteTime + j * (beatDuration / 2);
          
          // Create noise buffer
          const bufferSize = 256;
          const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
          const data = noiseBuffer.getChannelData(0);
          
          for (let k = 0; k < bufferSize; k++) {
            data[k] = (Math.random() * 2 - 1) * 0.8;
          }
          
          const noiseSource = audioContext.createBufferSource();
          noiseSource.buffer = noiseBuffer;
          
          const hipassFilter = audioContext.createBiquadFilter();
          hipassFilter.type = 'highpass';
          hipassFilter.frequency.value = 4000;
          
          const hihatGain = audioContext.createGain();
          hihatGain.gain.setValueAtTime(0, hihatTime);
          hihatGain.gain.linearRampToValueAtTime(0.06, hihatTime + 0.005);
          hihatGain.gain.exponentialRampToValueAtTime(0.0005, hihatTime + 0.1);
          
          noiseSource.connect(hipassFilter).connect(hihatGain).connect(musicGain);
          noiseSource.start(hihatTime);
          noiseSource.stop(hihatTime + 0.12);
        }
      }
    }
    
    // Start the pattern
    const startTime = audioContext.currentTime + 0.05;
    schedulePattern(startTime);
    
    // Schedule recurring patterns
    const patternDuration = patternLength * beatDuration;
    musicSchedulerId = setInterval(() => {
      if (musicRunning && audioContext) {
        schedulePattern(audioContext.currentTime + 0.05);
      }
    }, patternDuration * 1000 - 50);
    
  } catch (e) {
    console.log('Music error:', e);
    musicRunning = false;
  }
}

function stopMusic() {
  musicRunning = false;
  if (musicSchedulerId) {
    clearInterval(musicSchedulerId);
    musicSchedulerId = null;
  }
}

// Enhanced Sound Effects
function playBubblePop() {
  if (!audioContext) return;
  try {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    const currentTime = audioContext.currentTime;
    
    osc.type = 'square';
    osc.frequency.setValueAtTime(900, currentTime);
    osc.frequency.exponentialRampToValueAtTime(1600, currentTime + 0.06);
    
    gain.gain.setValueAtTime(0.001, currentTime);
    gain.gain.exponentialRampToValueAtTime(0.4, currentTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0008, currentTime + 0.14);
    
    osc.connect(gain).connect(sfxGain);
    osc.start(currentTime);
    osc.stop(currentTime + 0.16);
  } catch (e) {
    console.log('Sound effect error');
  }
}

function playThunk() {
  if (!audioContext) return;
  try {
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    const currentTime = audioContext.currentTime;
    
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(180, currentTime);
    osc.frequency.exponentialRampToValueAtTime(90, currentTime + 0.12);
    
    gain.gain.setValueAtTime(0.001, currentTime);
    gain.gain.exponentialRampToValueAtTime(0.5, currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0008, currentTime + 0.22);
    
    osc.connect(gain).connect(sfxGain);
    osc.start(currentTime);
    osc.stop(currentTime + 0.25);
  } catch (e) {
    console.log('Sound effect error');
  }
}

// Game Objects
function createPipe() {
  const gap = Math.max(180, canvas.displayHeight * 0.3);
  const pipeWidth = 50;
  const minHeight = 50;
  const maxHeight = canvas.displayHeight - gap - minHeight;
  const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;

  // Precompute crack segments for visual detail
  function generateCracks(x, y, w, h) {
    const cracks = [];
    const verticalCount = 3;
    const horizontalCount = 3;
    
    // Vertical cracks
    for (let i = 0; i < verticalCount; i++) {
      const baseX = x + 10 + (i * (w - 20) / (verticalCount - 1));
      let currentY = y;
      const segments = [];
      
      while (currentY < y + h) {
        const step = 12 + Math.random() * 18;
        const nextY = Math.min(currentY + step, y + h);
        const offsetX = baseX + (Math.random() - 0.5) * 8;
        segments.push({x: offsetX, y: nextY});
        currentY = nextY;
      }
      cracks.push({type: 'vertical', start: {x: baseX, y: y}, points: segments});
    }
    
    // Horizontal cracks
    for (let i = 0; i < horizontalCount; i++) {
      const baseY = y + 15 + (i * (h - 30) / horizontalCount);
      const segments = [];
      let currentX = x;
      const endX = x + w;
      
      while (currentX < endX) {
        const step = 10 + Math.random() * 14;
        const nextX = Math.min(currentX + step, endX);
        const offsetY = baseY + (Math.random() - 0.5) * 6;
        segments.push({x: nextX, y: offsetY});
        currentX = nextX;
      }
      cracks.push({type: 'horizontal', start: {x: x, y: baseY}, points: segments});
    }
    
    return cracks;
  }

  const pipe = {
    x: canvas.displayWidth,
    width: pipeWidth,
    topHeight,
    bottomY: topHeight + gap,
    bottomHeight: canvas.displayHeight - (topHeight + gap),
    passed: false,
    topCracks: generateCracks(canvas.displayWidth, 0, pipeWidth, topHeight),
    bottomCracks: generateCracks(canvas.displayWidth, topHeight + gap, pipeWidth, canvas.displayHeight - (topHeight + gap))
  };

  pipes.push(pipe);
}

function createBadge() {
  const badgeType = badgeTypes[Math.floor(Math.random()*badgeTypes.length)];
  badges.push({
    x: canvas.displayWidth + Math.random()*200,
    y: Math.random()*(canvas.displayHeight-200)+100,
    width: 40, height: 40, collected: false,
    bob: Math.random()*Math.PI*2, type: badgeType
  });
}

function createParticle(x,y) {
  particles.push({
    x, y,
    vx:(Math.random()-0.5)*4,
    vy:(Math.random()-0.5)*4,
    life: 28, maxLife: 28
  });
}

// Drawing Functions
function drawBackground() {
  const grad = ctx.createLinearGradient(0,0,0,canvas.displayHeight);
  grad.addColorStop(0,'#87ceeb');
  grad.addColorStop(0.3,'#4682b4');
  grad.addColorStop(0.7,'#4169e1');
  grad.addColorStop(1,'#0047ab');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,canvas.displayWidth,canvas.displayHeight);

  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 2;
  for (let i=0;i<2;i++){
    ctx.beginPath();
    const yBase = canvas.displayHeight*0.8 + Math.sin(frame*0.02 + i)*16;
    ctx.moveTo(0, yBase);
    for (let x=0;x<=canvas.displayWidth;x+=12){
      const y = canvas.displayHeight*0.8 + Math.sin(x*0.01 + frame*0.02 + i)*16;
      ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
}

function drawPlayer() {
  ctx.save();
  ctx.translate(player.x + player.width/2, player.y + player.height/2);

  const rotation = Math.max(-0.5, Math.min(0.5, player.velocity*0.03));
  ctx.rotate(rotation);

  ctx.beginPath();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(255,255,255,0.6)';
  ctx.arc(0,0, player.width/2 + 3, 0, Math.PI*2);
  ctx.stroke();

  ctx.font = `${player.width}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('üêΩ', 0, 1);

  ctx.restore();
}

function drawPipes() {
  pipes.forEach(pipe => {
    // Draw top pipe
    ctx.fillStyle = '#3e6b1f';
    ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 3;
    ctx.strokeRect(pipe.x, 0, pipe.width, pipe.topHeight);

    // Draw top pipe cracks
    ctx.strokeStyle = '#1a3009';
    ctx.lineWidth = 1;
    ctx.lineCap = 'round';
    pipe.topCracks.forEach(crack => {
      ctx.beginPath();
      ctx.moveTo(crack.start.x, crack.start.y);
      crack.points.forEach(point => ctx.lineTo(point.x, point.y));
      ctx.stroke();
    });

    // Draw bottom pipe
    ctx.fillStyle = '#7d2323';
    ctx.fillRect(pipe.x, pipe.bottomY, pipe.width, pipe.bottomHeight);
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 3;
    ctx.strokeRect(pipe.x, pipe.bottomY, pipe.width, pipe.bottomHeight);

    // Draw bottom pipe cracks
    ctx.strokeStyle = '#3d0e0e';
    ctx.lineWidth = 1;
    pipe.bottomCracks.forEach(crack => {
      ctx.beginPath();
      ctx.moveTo(crack.start.x, crack.start.y);
      crack.points.forEach(point => ctx.lineTo(point.x, point.y));
      ctx.stroke();
    });
  });
}

function drawBadges() {
  badges.forEach(b=>{
    if (b.collected) return;
    b.bob += 0.1;
    const bobOffset = Math.sin(b.bob)*5;
    
    ctx.save();
    ctx.translate(b.x + b.width/2, b.y + b.height/2 + bobOffset);

    ctx.font = `${b.width}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(b.type, 0, 0);

    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0,0,b.width/2 + 4,0,Math.PI*2);
    ctx.stroke();

    ctx.restore();
  });
}

function drawParticles() {
  particles.forEach(p=>{
    const a = p.life/p.maxLife;
    ctx.fillStyle = `rgba(255,255,255,${a})`;
    ctx.beginPath();
    ctx.arc(p.x,p.y,2,0,Math.PI*2);
    ctx.fill();
  });
}

// Game Update
function updateGame() {
  if (gameState !== 'playing') return;
  frame++;

  // Player movement - Reverted to original gradual mechanics
  if (isSpacePressed || isMousePressed) {
    player.velocity += player.upForce;
    if (player.velocity < player.maxUpVelocity) player.velocity = player.maxUpVelocity;
  } else {
    player.velocity += player.gravity;
    if (player.velocity > player.maxDownVelocity) player.velocity = player.maxDownVelocity;
  }
  player.y += player.velocity;

  // Spawn objects with original timing
  const spawnRate = Math.max(80, 100 - Math.floor(score / 10) * 3);
  if (frame % spawnRate === 0) createPipe();
  if (frame % Math.max(60, 90 - Math.floor(score / 20) * 3) === 0) createBadge();

  // Move objects and update crack positions
  pipes.forEach(pipe => {
    pipe.x -= 3 * gameSpeed;
    
    // Update crack positions to move with pipes
    pipe.topCracks.forEach(crack => {
      crack.start.x -= 3 * gameSpeed;
      crack.points.forEach(point => point.x -= 3 * gameSpeed);
    });
    pipe.bottomCracks.forEach(crack => {
      crack.start.x -= 3 * gameSpeed;
      crack.points.forEach(point => point.x -= 3 * gameSpeed);
    });
  });
  
  badges.forEach(b => b.x -= 2 * gameSpeed);
  particles.forEach(p => {
    p.x += p.vx * gameSpeed;
    p.y += p.vy;
    p.life--;
  });

  // Cleanup
  pipes = pipes.filter(p => p.x + p.width > 0);
  badges = badges.filter(b => !b.collected && b.x + b.width > 0);
  particles = particles.filter(p => p.life > 0);

  // Scoring
  pipes.forEach(pipe => {
    if (!pipe.passed && pipe.x + pipe.width < player.x) {
      pipe.passed = true;
      score++;
      createParticle(player.x, player.y);
    }
  });

  // Badge collection with improved collision detection
  badges.forEach(b => {
    if (!b.collected &&
      player.x + player.width/4 < b.x + b.width &&
      player.x + player.width*3/4 > b.x &&
      player.y + player.height/4 < b.y + b.height &&
      player.y + player.height*3/4 > b.y) {
        b.collected = true;
        badgeCount++;
        score += 5;
        for (let i=0;i<5;i++) createParticle(b.x, b.y);
        playBubblePop();
      }
  });

  // Collisions with improved detection
  if (player.y + player.height > canvas.displayHeight - 20 || player.y < 20) {
    playThunk();
    endGame();
    return;
  }

  for (const pipe of pipes) {
    const hitX = (player.x + 5 < pipe.x + pipe.width) && (player.x + player.width - 5 > pipe.x);
    const hitY = (player.y + 5 < pipe.topHeight) || (player.y + player.height - 5 > pipe.bottomY);
    if (hitX && hitY) {
      playThunk();
      endGame();
      return;
    }
  }

  // Update UI
  document.getElementById('score').textContent = score;
  document.getElementById('badges').textContent = badgeCount;

  // Speed up gradually
  gameSpeed = 1 + Math.floor(score / 50) * 0.1;
  if (gameSpeed > 2) gameSpeed = 2;
}

// Game Loop
function draw() {
  ctx.clearRect(0,0,canvas.displayWidth,canvas.displayHeight);
  drawBackground();
  drawPipes();
  drawBadges();
  drawParticles();
  drawPlayer();
  updateGame();
  requestAnimationFrame(draw);
}

// Game Flow
function startGame() {
  console.log('Starting game...');
  initAudio();
  
  // Stop menu music and start game music
  stopMusic();
  setTimeout(() => startMusic(), 100);
  
  gameState = 'playing';
  score = 0;
  badgeCount = 0;
  frame = 0;
  gameSpeed = 1;
  player.y = Math.min(300, canvas.displayHeight/2);
  player.velocity = 0;
  pipes = [];
  badges = [];
  particles = [];

  document.getElementById('finalScore').classList.remove('new-record');
  document.getElementById('finalBadges').classList.remove('new-record');

  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameOver').style.display = 'none';
  document.getElementById('gameUI').style.display = 'block';
}

function endGame() {
  console.log('Ending game...');
  gameState = 'gameOver';
  stopMusic();
  
  let newScoreRecord = false;
  let newBadgeRecord = false;
  
  if (score > highScore) {
    highScore = score;
    newScoreRecord = true;
  }
  
  if (badgeCount > highBadges) {
    highBadges = badgeCount;
    newBadgeRecord = true;
  }
  
  if (newScoreRecord || newBadgeRecord) {
    saveHighScore();
  }
  
  document.getElementById('finalScore').textContent = score;
  document.getElementById('finalBadges').textContent = badgeCount;
  updateHighScoreDisplay();
  
  setTimeout(() => {
    if (newScoreRecord) {
      document.getElementById('finalScore').classList.add('new-record');
    }
    if (newBadgeRecord) {
      document.getElementById('finalBadges').classList.add('new-record');
    }
  }, 100);
  
  document.getElementById('gameOver').style.display = 'block';
  document.getElementById('gameUI').style.display = 'none';
}

function goHome() {
  console.log('Going home...');
  gameState = 'start';
  stopMusic();
  
  // Start menu music
  setTimeout(() => {
    initAudio();
    startMusic();
  }, 100);
  
  document.getElementById('gameOver').style.display = 'none';
  document.getElementById('gameUI').style.display = 'none';
  document.getElementById('startScreen').style.display = 'block';
}

// Controls
let spaceKeyDown = false;

document.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    if (gameState === 'playing' && !spaceKeyDown) {
      isSpacePressed = true;
      spaceKeyDown = true;
    }
  }
  if (e.code === 'Enter' && gameState === 'start') {
    startGame();
  }
});

document.addEventListener('keyup', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    isSpacePressed = false;
    spaceKeyDown = false;
  }
});

// Mouse/Touch controls
canvas.addEventListener('mousedown', e => {
  e.preventDefault();
  if (gameState === 'playing') {
    isMousePressed = true;
  }
});

canvas.addEventListener('mouseup', e => { 
  e.preventDefault();
  isMousePressed = false; 
});

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (gameState === 'playing') {
    isMousePressed = true;
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  isMousePressed = false;
}, { passive: false });

// Button Events - Using simple onclick
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('startBtn').onclick = function() {
    console.log('Start button clicked!');
    startGame();
  };
  
  document.getElementById('restartBtn').onclick = function() {
    console.log('Restart button clicked!');
    startGame();
  };
  
  document.getElementById('homeBtn').onclick = function() {
    console.log('Home button clicked!');
    goHome();
  };
});

// Initialize
loadHighScore();

// Start menu music after page loads
setTimeout(() => {
  initAudio();
  startMusic();
}, 200);

draw();
</script>
</body>
</html>
